// Copyright (C) 2023-2025 Fraunhofer ITWM
// License: https://raw.githubusercontent.com/cc-hpc-itwm/mcs/main/LICENSE

#pragma once

#include <mcs/rpc/Client.hpp>
#include <mcs/rpc/Concepts.hpp>
#include <mcs/rpc/access_policy/Sequential.hpp>
#include <mcs/rpc/multi_client/Concepts.hpp>
#include <mcs/rpc/multi_client/ParallelCallsLimit.hpp>

namespace mcs::rpc::multi_client
{
  // Calls the remote handlers for the commands generated by the
  // command generator for each of the clients. The results are
  // collected via Collect. The command generator is called at most
  // once for each client in the order they are given in the
  // parameter. The collector is called at most once for each
  // result/error, in unspecified order. If the collector throws an
  // exception, either when collecting a result or when collecting an
  // error, then no further calls to the collector will happen. There
  // will be no more than the given limit of parallel calls ongoing at
  // the same time.
  //
  // Note: An early exception in the collector of one client might
  // drop async operations in another client. That means there might
  // be calls ongoing even after call_and_collect has returned! That
  // implies that clients are only safe to use if they use
  //
  //   access_policy::Sequential
  //
  // Other access policies might be used only if the collector does
  // not throw any exception. The standard rules for the access policy
  // apply, namely that Exclusive must not run multiple concurent
  // call_and_collect.
  //
  template< is_command Command
          , typename CommandGenerator
          , typename Collect
          , typename Clients
          >
    requires (  is_result_collect<Collect, Clients, Command>
             && is_command_generator<CommandGenerator, Clients, Command>
             )
    auto call_and_collect
      ( CommandGenerator
      , Collect&
      , Clients&&
      , ParallelCallsLimit
      ) -> void
      ;

  // The same behavior with one more level of indirection for the
  // delivery of the clients and the commands. Users specify
  // identifiers for clients and both, client and command, are
  // requested by those identifiers.
  //
  // EXAMPLE:
  //
  // call_and_collect<Command> (command, collect, clients, parallel_calls_limit)
  // {
  //   return call_and_collect<Command>
  //     ( std::move (command)
  //     , [] (auto& client) { return client; }
  //     , collect
  //     , std::forward<Clients> (clients)
  //     , parallel_calls_limit
  //     );
  // }
  //
  template< is_command Command
          , typename CommandGenerator
          , typename ClientGenerator
          , typename Collect
          , typename ClientIDs
          >
    requires (  is_result_collect<Collect, ClientIDs, Command>
             && is_command_generator<CommandGenerator, ClientIDs, Command>
             )
    auto call_and_collect
      ( CommandGenerator
      , ClientGenerator
      , Collect&
      , ClientIDs const&
      , ParallelCallsLimit
      ) -> void
      ;
}

#include "detail/call_and_collect.ipp"
